#ifndef BCEDATA_HPP
#define BCEDATA_HPP

#include "bcecommon.hpp"
#include "bceexception.hpp"
#include <boost/serialization/list.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/map.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/serialization/utility.hpp>

// Class for storing bndry points with PSM routine.
class BCEPoint
{
public: 
  vector<double> data;
  
  BCEPoint():data(2,0.0) {};
  BCEPoint(vector<double> newData):data(newData) {};
  BCEPoint(double p1, double p2):data(2,0.0) {data[0]=p1; data[1]=p2;};
  ~BCEPoint() {};
  
  BCEPoint &operator=(const BCEPoint &rhs) 
  {
    if (this!=&rhs)
      this->data = rhs.data;

    return *this;
  }

  int operator==(const BCEPoint &rhs)
  {
    if ( this->data != rhs.data ) return 0;
    return 1;
  }

  int operator<(const BCEPoint & rhs)
  {
    return 0;
  }

  friend ostream& operator<<(ostream& output, const BCEPoint &rhs)
  {
    output << rhs.data[0] << " " << rhs.data[1] << endl;

    return output;
  }
};

// Class for storing equilibria from PSM. The only reason we don't
// just treat this as a vector<double> is that we might want to add
// functionality later, e.g. for sorting.
class BCEEquilibrium
{
public:
  map<int,double> distribution;
  double key;

public:
  BCEEquilibrium () {}
  BCEEquilibrium (const map<int,double> & data):
    distribution(data), key(0.0) 
  {}

  ~BCEEquilibrium() {}

  BCEEquilibrium& operator=(const BCEEquilibrium & rhs)
  {
    if (this!=&rhs)
      {
	this->distribution=rhs.distribution;
	this->key=rhs.key;
      }
    return *this;
  }

  template <class Archive>
  void serialize(Archive& ar, const unsigned int version)
  {
    ar & distribution & key;
  }

  friend class boost::serialization::access;
  friend class BCEData;
}; // BCEEquilibrium

// This class is a function operator for sorting equilibria in a
// BCEData object.
class BCEComparator
{
public:
  enum Mode
    {
      ANGLE, EQUALITY
    };
private:
  vector<int> obj;
  vector<double> origin;
  Mode currentMode;

public:
  BCEComparator(): obj(2,0) {};
  bool operator() (const vector<double> &, 
		   const vector<double> &);
  double operator() (const vector<double> &, 
		     const vector<double> &, 
		     const vector<double> &);
  void setObjectives(const vector<int> &);
  void setOrigin(const vector<double> &);
  void setMode(Mode);
  
  double cosine(const vector<double> &);
  double norm(const vector<double> &);
}; // BCEComparator

// Class for iterating through arrays.
class BCECounter
{
public:
  int variable;
  int marginal;
  int stateType;

  int numPlayers;
  int state;
  vector<int> actions;
  vector<int> types;

  BCECounter() {}

  BCECounter(int _numStates,const vector<int> & _numActions, const vector<int> & _numTypes,
	     const vector<int> &_stateConditions, 
	     const vector< vector<int> > & _actionConditions, 
	     const vector< vector<int> > & _typeConditions,
	     bool _stateMarginal,
	     const vector<bool> & _actionMarginal,
	     const vector<bool> & _typeMarginal):
    numPlayers(2),
    numStates(_numStates), numActions(_numActions),
    numTypes(_numTypes), stateConditions(_stateConditions),
    actionConditions(_actionConditions), 
    typeConditions(_typeConditions),
    stateMarginal(_stateMarginal),
    actionMarginal(_actionMarginal),
    typeMarginal(_typeMarginal),
    actions(2,0), types(2,0),
    actionIncrements(2,0), typeIncrements(2,0),
    actionDecrements(2,0), typeDecrements(2,0),
    stateIncrementMarginal(0),
    actionIncrementsMarginal(2,0), typeIncrementsMarginal(2,0),
    actionDecrementsMarginal(2,0), typeDecrementsMarginal(2,0),
    actionIncrementsStateType(2,0), typeIncrementsStateType(2,0),
    typeDecrementsStateType(2,0)
  {
    initialize();
  }
  
  void initialize();

  bool operator++(); 

  int getNumMarginal() {return numMarginalVariables;}
  
private:
  int stateIndex;
  vector<int> actionIndices;
  vector<int> typeIndices;

  int numMarginalVariables;
  int numVariables;

  vector<int> stateConditions;
  vector< vector<int> > actionConditions;
  vector< vector<int> > typeConditions;

  bool stateMarginal;
  vector<bool> actionMarginal;
  vector<bool> typeMarginal;
  
  int numStates;
  vector<int> numActions;
  vector<int> numTypes;

  vector<int> actionIncrements;
  vector<int> typeIncrements;
  vector<int> actionDecrements;
  vector<int> typeDecrements;

  int stateIncrementMarginal;
  vector<int> actionIncrementsMarginal;
  vector<int> typeIncrementsMarginal;
  vector<int> actionDecrementsMarginal;
  vector<int> typeDecrementsMarginal;

  vector<int> actionIncrementsStateType;
  vector<int> typeIncrementsStateType;
  vector<int> typeDecrementsStateType;
};

// This class handles all of the data generated by the BCEBase. It
// also contains statistical routines for analyzing the list of
// equilibria.
class BCEData
{
public:
  int numPlayers;
  int numStates;
  vector<int> numTypes;
  vector<int> numActions;
  int numObjectives;

  bool isPrivateValues;
  vector<int> numValues;

  vector<string> objectiveNames;

  int numActions_total;
  int numTypes_total;
  int numActionsTypesPerPlayer_total;
  int numActionsTypes_total;

  list<BCEEquilibrium> newEquilibria;
  vector<BCEEquilibrium> equilibria;

  int currentEquilibrium;

  // Stores objective information. Syntax is
  // objectives[objectiveCounter][actionCounter].
  vector< vector<double> > objectives; 
  vector<double> prior;
  vector<bool> dominated;

  void indexToStateActions(int index, int &state, vector<int> &actions) const;
  void indexToStateTypes(int index, int &state, vector<int> &types) const;
  void indexToTypeAction(int index, int player, int &type, int &action) const;
  void indexToStateTypesActions(int index, int &state, vector<int> &types, vector<int> &actions) const; 

  int stateTypesActionsToMarginalIndex(int state, 
				       const vector<int> &types, 
				       const vector<int> &actions,
				       bool stateMarginal,
				       const vector<bool> &actionMarginal,
				       const vector<bool> &typeMarginal) const;

  void countActionsTypes();

  template <class Archive>
  void serialize(Archive& ar, const unsigned int version)
  {
    ar & numPlayers;
    ar & numStates;
    ar & numTypes;
    ar & numActions;
    ar & numObjectives;

    ar & isPrivateValues;
    ar & numValues;

    ar & objectiveNames;

    ar & numActions_total;
    ar & numTypes_total;
    ar & numActionsTypesPerPlayer_total;
    ar & numActionsTypes_total;

    ar & newEquilibria;
    ar & equilibria;

    ar & currentEquilibrium;

    // Stores objective information. Syntax is
    // objectives[objectiveCounter][actionCounter].
    ar & objectives; 
    ar & prior;
    ar & dominated;
  }

public:
  BCEData ():currentEquilibrium(0), isPrivateValues(false) {}

  BCEData (int numPlayersArg,
	   int numStatesArg, 
	   const vector<int> & numActionsArg, 
	   const vector<int> & numTypesArg,
	   int numObjectivesArg);

  ~BCEData () {}

  // We do not do this in the constructor, since BCEBase has a BCEData
  // object that gets initialized in the constructor, and we cannot
  // simply pass the virtual methods for objectives, prior, and
  // dominated to the BCEData constructor.
  void setObjectivesPriorDominated(const vector< vector<double> > & objectivesArg,
				   const vector<double> & priorArg,
				   const vector<bool> & dominatedArg);
  
  void setObjectiveNames(const vector<string> & _names);

  /* Managing the equilibria. */
  // Adds another equilibrium to the end of the list newEquilibria
  void addEquilibrium(const map<int,double> & distr);
  // Clears all equilibria
  void clearEquilibria();
  // Appends the list of newEquilibria to the vector
  // equilibria. Clears newEquilibria.
  void consolidateEquilibria();
  // Sorts equilibria according to the two objective functions. Throws
  // out redundant equilibria.
  void sortEquilibria(vector<int>& obj);
  // Helper to sortEquilibria
  void grahamScan(vector< vector<double> > & points,
		  vector<int> &obj);
  // Gets the equilibrium corresponding to equilibriumIndex and puts
  // it in distr.
  void getEquilibrium(int equilibriumIndex, BCEEquilibrium &equilibrium) const;
  // Sets the current equilibrium to the equilibrium with index
  // i. That vector must be an element of the vector equilibria. 
  void setCurrentEquilibrium(int equilibriumIndex);

  void setNumValues(const vector<int> &_numValues);

  /* Operators */
  // Overload the << operator.
  BCEData& operator=(const BCEData &rhs);
  friend ostream& operator<<(ostream& output, BCEData &rhs);

  /* Statistical routines */
  // This method will calculate the expected objectives for each of
  // the equilibrium distributions in "equilibria". Optionally can be
  // called with a particular given distribution, which is useful,
  // e.g., for calculating objectives with a conditional distribution.
  void getExpectedObjectives(vector<double> &objectiveValues) const;
  void getExpectedObjectives(vector< vector<double> > &objectiveValues) const;
  void getExpectedObjectives(vector<double> &objectiveValues,
			     const map<int,double> &distribution) const;

  // Calculates the expected payoff resulting from each action for the
  // given player, type, and recommended action.
  double getDeviationObjectives(int player, int action, int type,
			      vector< vector<double> > & objectiveValues) const;

  // A general method for calculating conditional marginal
  // distributions. The state must be equal to an element of
  // stateConditions, action[i] must be an element of
  // actionConditions[i], etc. If the given condition vector is empty,
  // no restriction is imposed. The distribution is projected onto
  // variables with a logical true in <var>Marginal. Returns the
  // probability of the event we are conditioning on.
  double getConditionalMarginal(const vector<int> &stateConditions, 
			      const vector< vector<int> > &actionConditions,
			      const vector< vector<int> > &typeConditions,
			      bool stateMarginal,
			      const vector<bool> &actionMarginal,
			      const vector<bool> &typeMarginal,
			      vector<double> &distribution) const;

  static void save(const BCEData & data, const char* filename)
  {
    ofstream ofs(filename);

    if (ofs.good())
      {
	boost::archive::text_oarchive oa(ofs);
	oa << data;
	ofs.close();
      }
    else
      throw(BCEException(BCEException::FailedOpen));

  }

  static void load(BCEData & data, const char* filename)
  {
    ifstream ifs(filename);

    if (ifs.good())
      {
	boost::archive::text_iarchive ia(ifs);
	ia >> data;
	ifs.close();
      }
    else
      throw(BCEException(BCEException::FailedOpen));

  }

  friend class boost::serialization::access;
}; // BCEData

#endif
