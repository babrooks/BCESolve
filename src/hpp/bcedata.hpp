#ifndef BCEDATA_HPP
#define BCEDATA_HPP

#include "bcecommon.hpp"
#include "bceexception.hpp"
#include "bcequilibrium.hpp"
#include "bcecounter.hpp"

#include <boost/serialization/list.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/map.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/serialization/utility.hpp>

// This class handles all of the data generated by the BCEBase. It
// also contains statistical routines for analyzing the list of
// equilibria.
class BCEData
{
public:
  int numPlayers;
  int numStates;
  vector<int> numTypes;
  vector<int> numActions;
  int numObjectives;

  bool isPrivateValues;
  vector<int> numValues;

  vector<string> objectiveNames;

  int numActions_total;
  int numTypes_total;
  int numActionsTypesPerPlayer_total;
  int numActionsTypes_total;

  list<BCEquilibrium> newEquilibria;
  vector<BCEquilibrium> equilibria;

  int currentEquilibrium;

  // Stores objective information. Syntax is
  // objectives[objectiveCounter][actionCounter].
  vector< vector<double> > objectives; 
  vector<double> prior;
  vector<bool> dominated;

  void indexToStateActions(int index, int &state, vector<int> &actions) const;
  void indexToStateTypes(int index, int &state, vector<int> &types) const;
  void indexToTypeAction(int index, int player, int &type, int &action) const;
  void indexToStateTypesActions(int index, int &state, vector<int> &types, vector<int> &actions) const; 

  int stateTypesActionsToMarginalIndex(int state, 
				       const vector<int> &types, 
				       const vector<int> &actions,
				       bool stateMarginal,
				       const vector<bool> &actionMarginal,
				       const vector<bool> &typeMarginal) const;

  void countActionsTypes();

  template <class Archive>
  void serialize(Archive& ar, const unsigned int version)
  {
    ar & numPlayers;
    ar & numStates;
    ar & numTypes;
    ar & numActions;
    ar & numObjectives;

    ar & isPrivateValues;
    ar & numValues;

    ar & objectiveNames;

    ar & numActions_total;
    ar & numTypes_total;
    ar & numActionsTypesPerPlayer_total;
    ar & numActionsTypes_total;

    ar & newEquilibria;
    ar & equilibria;

    ar & currentEquilibrium;

    // Stores objective information. Syntax is
    // objectives[objectiveCounter][actionCounter].
    ar & objectives; 
    ar & prior;
    ar & dominated;
  }

public:
  BCEData ():currentEquilibrium(0), isPrivateValues(false) {}

  BCEData (int numPlayersArg,
	   int numStatesArg, 
	   const vector<int> & numActionsArg, 
	   const vector<int> & numTypesArg,
	   int numObjectivesArg);

  ~BCEData () {}

  // We do not do this in the constructor, since BCEBase has a BCEData
  // object that gets initialized in the constructor, and we cannot
  // simply pass the virtual methods for objectives, prior, and
  // dominated to the BCEData constructor.
  void setObjectivesPriorDominated(const vector< vector<double> > & objectivesArg,
				   const vector<double> & priorArg,
				   const vector<bool> & dominatedArg);
  
  void setObjectiveNames(const vector<string> & _names);

  /* Managing the equilibria. */
  // Adds another equilibrium to the end of the list newEquilibria
  void addEquilibrium(const map<int,double> & distr);
  // Clears all equilibria
  void clearEquilibria();
  // Appends the list of newEquilibria to the vector
  // equilibria. Clears newEquilibria.
  void consolidateEquilibria();
  // Gets the equilibrium corresponding to equilibriumIndex and puts
  // it in distr.
  void getEquilibrium(int equilibriumIndex, BCEquilibrium &equilibrium) const;
  // Sets the current equilibrium to the equilibrium with index
  // i. That vector must be an element of the vector equilibria. 
  void setCurrentEquilibrium(int equilibriumIndex);

  void setNumValues(const vector<int> &_numValues);

  /* Operators */
  // Overload the << operator.
  BCEData& operator=(const BCEData &rhs);
  friend ostream& operator<<(ostream& output, BCEData &rhs);

  /* Statistical routines */
  // This method will calculate the expected objectives for each of
  // the equilibrium distributions in "equilibria". Optionally can be
  // called with a particular given distribution, which is useful,
  // e.g., for calculating objectives with a conditional distribution.
  void getExpectedObjectives(vector<double> &objectiveValues) const;
  void getExpectedObjectives(vector< vector<double> > &objectiveValues) const;
  void getExpectedObjectives(vector<double> &objectiveValues,
			     const map<int,double> &distribution) const;

  // Calculates the expected payoff resulting from each action for the
  // given player, type, and recommended action.
  double getDeviationObjectives(int player, int action, int type,
			      vector< vector<double> > & objectiveValues) const;

  // A general method for calculating conditional marginal
  // distributions. The state must be equal to an element of
  // stateConditions, action[i] must be an element of
  // actionConditions[i], etc. If the given condition vector is empty,
  // no restriction is imposed. The distribution is projected onto
  // variables with a logical true in <var>Marginal. Returns the
  // probability of the event we are conditioning on.
  double getConditionalMarginal(const vector<int> &stateConditions, 
			      const vector< vector<int> > &actionConditions,
			      const vector< vector<int> > &typeConditions,
			      bool stateMarginal,
			      const vector<bool> &actionMarginal,
			      const vector<bool> &typeMarginal,
			      vector<double> &distribution) const;

  static void save(const BCEData & data, const char* filename)
  {
    ofstream ofs(filename);

    if (ofs.good())
      {
	boost::archive::text_oarchive oa(ofs);
	oa << data;
	ofs.close();
      }
    else
      throw(BCEException(BCEException::FailedOpen));

  }

  static void load(BCEData & data, const char* filename)
  {
    ifstream ifs(filename);

    if (ifs.good())
      {
	boost::archive::text_iarchive ia(ifs);
	ia >> data;
	ifs.close();
      }
    else
      throw(BCEException(BCEException::FailedOpen));

  }

  friend class boost::serialization::access;
}; // BCEData

#endif
