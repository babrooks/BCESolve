// This file is part of the BCESolve library for games of incomplete
// information
// Copyright (C) 2016 Benjamin A. Brooks and Robert J. Minton
// 
// BCESolve free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// BCESolve is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see
// <http://www.gnu.org/licenses/>.
// 
// Benjamin A. Brooks
// ben@benjaminbrooks.net
// Chicago, IL

/*!
  \mainpage BCESolve Documentation

  \section introsec Introduction

BCESolve is a library of routines for representing, solving, and
analyzing Bayes correlated equilibria (BCE), a solution concept
that generalized correlated equilibrium to games of incomplete
information. BCE, like correlated equilibria, are joint
distributions that satisfy a series of linear constraints. The
library utilizes Gurobi's linear programming package to solve
for BCE that maximize a given linear objective, such as expected
payoffs of the players.

  The package consists of two main components. The first piece is a
  library of C++ classes for representing and solving games of incomplete
  information, and the second is a graphical user interface (BCEViewer) for
  using and interacting with the solver library. The purpose of this
  guide is to give advanced users an overview of how the library and
  graphical interface are structured. 

  BCESolve makes use of external software packages: the Boost libraries
  are used for serialalization of data relating to games,
  which are represented with the BCEGame and BCEAbstractGame classes and are saved as .bgm
  files, and the solutions of games that are generated by
  the algorithmm, which are represented with the BCESolution and
  are saved as .bce files. The graphical
  interface uses the Qt framework and the Qt plotting library
  QCustomPlot. 

  \section installsec Installation

  BINARIES FOR BCEVIEWER - REMOVE REFERENCE IF WE DON'T DO THAT.
  ALSO FIX MAKEFILE REFERENCES.

  To use this software, you can directly download the BCEViewer
  binaries, which are precompiled for Linux and OS X. The source code
  is also available at www.benjaminbrooks.net/research.shtml. The code
  has been compiled on: CentOS 7 using gcc version 4.8.3 and Boost
  1.53; and on OS X using LLVM version 7.0.2 and Boost 1.57. In both
  cases, the BCEViewer was compiled using Qt 5.5. The class BCESolver
  uses Gurobi for linear programming, and the code was compiled with
  Gurobi 5.63 on Linux and Gurobi 6.50 on OS X. To compile the source and example code
  yourself, you need to change the relevant variables in localsettings.mk and locasettings2.mk
  to direct the compiler to Boost and Gurobi. Importantly, just directing
  the compiler to Gurobi is not sufficient; your Gurobi installation must be 
  associated with a valid license. A free academic license may be obtained here:
  <a href="http://www.gurobi.com/registration/academic-license-reg">Gurobi University License</a>. You can then build the desired examples by calling 
  "make examplename" (the .cpp or .hpp ending is not included) in 
  the example dirctory. After you
  build the source, you can build the BCEViewer program from the viewer directory
  by first calling "qmake" and then running "make".

  \section solversec Overview of the solver library

  The BCESolve library contains a series of classes for
  representing, solving, and analyzing BCE. The BCEAbstractGame class is a
  base class for representing games of incomplete information. One
  must derive from this class, and reimplement its
  BCEGame::objective and BCEGame::prior methods to reflect the
  payoff functions and the distribution of the state for the
  particular game of interest.

  The BCESolver class uses Gurobi to solve a game represented by an
  object derived from the BCEAbstractGame class, by maximizing a particular
  linear objective over all BCE for that game.

  The output from the BCESolver class is stored in a BCESolution
  object. BCESolution objects can be serialized and de-serialized, and
  the class also contains routines for analyzing the BCE contained
  within.

  For a more detailed description of the solver library and its usage,
  see \ref sourcepage.

  \section viewersec Overview of the graphical interface

  BCESolve includes an accompanying graphical interface. It is capable of displaying
  data in a BCESolution object. This includes plotting player payoffs for
  all equilibria, plotting deviation objectives for each player,
  and plotting the Bayes correlated equilibrium.
  It also includes a tab for creating custom games, using the class BCEGame,
  which is derived from BCEAbstractGame. The user can set the conditional
  distribution of types, objective payoffs, the prior over the states, and
  weights on the objectives for maximization. The user can solve these
  custom games within the viewer. Output is displayed in a log tab, and the 
  solution is displayed in the solution tab. The custom BCEGame can also
  be serialized and de-serialized.

  The interface contains three tabs: a solution tab, a game tab,
  and a log tab. The solution tab displays graphs depicting features of the currently
  loaded solution object. The game tab facilitates both creation of custom games
  and editing of games written in c++. Custom and edited games can be also be solved from
  within the game tab. The log tab outputs progress and numerical solutions
  for any games games solved within the interface. 

  The solution tab largely runs using two classes: BCEPlotHandler and BCEDataState. 
  BCEDataState contains solution data for the currently loaded solution and
  has methods for manipulating that data. It also contains the user controls
  in the solution tab. These controls make use of the BCELineEdit and
  BCESlider classes. When users interact with these controls, data is 
  manipulated to reflect new parameters, and signals are sent to BCEPlotHandler
  that data has been updated. Slots in BCEPlotHandler receives signals from BCEDataState
  and run routines to plot data. BCEPlotHandler makes use of the custom plot class BCEValueSetPlot,
  which adds the abilities to retrieve mouse-over graph coordinates and interact
  by clicking on the plot. It also uses the custom label class BCELabel, which
  serves to label all plots in the solution tab (some of them dynamically, as titles
  change when data is manipulated).

  The game tab is constructed by the class BCEGameHandler. The tables seen within the gametab
  are, from left to right, a BCEPayoffTableModel, a BCEConditionalTableModel,
  a BCEPriorTableModel, and a BCEObjWeightsTableModel. When data in these models is changed, the currently loaded BCEGame object is altered to 
  reflect the changes, and the model retrieves that new data from the game to display 
  in the model. Entering data into the model thus also reveals if the data was properly 
  entered into the game object. BCEGameHandler makes use of BCESolverWorker to solve games. When the solve button is clicked by the user, a BCESolverWorker object is initialized, moved to a new thread in order to preserve functionality of the program, and used to solve the game. Progress of the solve routine is sent to the log tab.

  The log tab layout is created by BCELogHandler. BCELogStream, which is initilized in
  main.cpp, serves to redirect all cout in the program to the log tab. 

  Finally, BCEWindow is called to create the high level layout containing the three tabs:
  a BCEPlotHandler object, a BCEGameHandler object, and a BCELogHandler object. It also
  creates the menu bar and implements methods for loading and saving both games and solutions.
    
  For more details about the object model underlying BCEViewer, see the
  \ref viewerpage.

  \section examplesec Examples

  For the benefit of the user, we have included several examples of
  how to use the BCESolve package. The file allpayauction.cpp is an example of a
  standard, common-values all pay auction in which bidders pay their bids, irrespective of winning.
  The accompanying header file, allpayauction.hpp, shows how to construct a simple BCEGame by specifying the objectives and prior over the states (uniform, in this example). The example commonvalueauction.hpp specifies a prior over values distributed according to the CDF \f$ v^{\alpha} \f$, where\f$ v \f$ denotes the value in [0,1].

  The example fpaknown.hpp formulates a private-values first-price auction.
  The header file shows to how implement private values within the library's
  state framework. The file fpaknown.cpp assumes that bidders know their own
  values. This file features the mapBoundary method, which traces out 
  the boundary for equilibria payoffs and allow the user to view different
  equilibria in the BCEViewer. This payoff set is saved in a data file, "fpaknown.dat,"
  so that it can also be analyzed elsewhere. The file fpaunknown.cpp assumes
  that bidders do not know their own values. 

  \section conclusionsec Final thoughts

  UPDATE FOR BCE. CURRENTLY SG.

  The package has many more features that the user will no doubt
  discover. Within the src folder is a src/MATLAB subfolder, that
  contains tools for interfacing between MATLAB and SGSolve. In
  particular, sgmex.cpp is a mex program that can be used to specify,
  solve, and analyze games from within MATLAB. There is also a matlab
  m-file sgmexbuild.m that was used to build sgmex on Linux and OS X
  with MATLAB R2014a. (Note that building sgmex is a bit tricky since
  the mex file needs to be linked to position independent code, and
  the default Boost libraries obtained through most package managers
  were not compiled with the -fPIC compiler flag. Thus, you may need
  to build the Boost serialization library from the source code.)

  This program would not have been possible without the support of
  numerous groups and the contributions of others, and it is entirely
  fitting and appropriate that their contributions should be
  acknowledged. In particular, this program was developed with and
  incorporates elements of a number of other open source projects,
  including the Qt application framework (www.qt.io), Emmanuel
  Eichhammer's QCustomPlot (www.qcustomplot.com), the Boost libraries
  (www.boost.org), and the GNU project (www.gnu.org). I would also
  like to gratefully acknowledge support from the Becker Friedman
  Institute, the University of Chicago, and the National Science
  Foundation.

  Finally, it should go without saying that this program is a work in
  progress. Feedback, bug reports, and contributions are much
  appreciated.

  Enjoy!

  Ben Brooks
  Chicago, IL
  ben@benjaminbrooks.net

  Robbie Minton
  Chicago, IL
  rminton@uchicago.edu
*/

/*! \defgroup src BCESolve library
  
  @brief The main solver library.

  For a detailed description of the BCESolve library, see \ref
  sourcepage.
 */

/*! \defgroup viewer BCEViewer graphical interface

  @brief The graphical user interface.

  For a detailed description of the BCEViewer object model, see \ref
  viewerpage.
 */

/** \example allpayauction.hpp
    \example allpayauction.cpp
    \example fparandomrp.hpp
    \example fparandomrp.cpp
    \example hybridentryreserve.hpp
    \example hybridentryreserve.cpp
    \example postedprice.hpp
    \example postedprice.cpp
    \example fpagame.hpp
    \example fpaknown.hpp
    \example fpaknown.cpp
    \example fpaunknown.hpp
    \example fpaunknown.cpp
 */

/*! \page sourcepage The BCESolve library

  @brief A detailed description of the BCESolve library.

  \section srcoverviewsec Overview

  The source module is comprised of a library of classes for
  specifying, solving, and exploring the solutions of two player
  games with incomplete information. A
  list of classes is contained here: \ref src. This page provides an
  overview of the object model, with additional details in the
  respective class pages. 

  \section srcgamesec Specifying a game
  
  The first step in using the BCESolve library is translating the
  abstract formulation of a game into a format that can be
  understood by the library. This translation is facilitated by the
  BCEAbstractGame and BCEGame classes. 

BCEAbstractGame has protected data members that store the
number of actions, number of states, number of types, number of objectives, and whether the game has a product structure. BCEAbstractGame has multiple constructors. The default constructor is used primarily for creating "blank" games within the graphical interface. The second constructor takes four integer inputs, each specifying one of the above-mentioned parameters, and creates a game where each player has the same number of types and actions. The third constructor instead takes two-element vectors of actions and types. This constructor allows players to have different numbers of actions and types.

  There are two parameters in the BCEAbstract
  class which deserve special mention. The first is called
  "hasProductStructureData," which...

  The second is the "objectiveLabels" member, which enables the user to name
  the objectives of the game. These labels will be displayed in the graphical
  interface when the game is loaded. If no names are provided, the first two 
  objectives will be called "Player 0 Payoff" and "Player 1 Payoff" by default.
  Subsequent objectives are denoted "Objective k."

  The BCEGame class derives from BCEAbstractGame. Its private members include
  the payoffs for each objective, the prior over each state, the conditional 
  distribution of types, data for dominated actions, and data for feasible deviations.

  BCEGame objects can be serialized and deserialized through static
  BCEGame::save and BCEGame::load methods. See allpayauction.cpp for an
  example. Serialized BCEGame objects can be loaded by BCEViewer.

  \section srcsolversec Solving a game

  Once one has specified the game, the next step is to solve that game
  by constructing a BCESolver. The BCESolver constructor requires the input 
  of a BCEAbstractGame or a BCEAbstractGame derived object, such as a BCEGame. Once the
  BCESolver is constructed, the computation of the Bayes correlated equilibrium is
  invoked first by calling BCESolver::populate(), which populates probability and incentive constraints, and then by calling using BCESolver::solve, which uses Gurobi to solve the resulting linear program.

  MapBoundary/mapFrontier section...

  \section srcsolutionsec Using the solution

  The output of the algorithm is stored in an object of type
  BCESolution, which is a member of BCESolver and can be accessed using
  the BCESolver::getSolution method. 

  BCESolution contains methods for accessing data of interest within
  the solution and accompanying game objects. BCECounter is used to handle linear indexing of
  data vectors seamlessly. The getExpectedObjectives method, for example,
  uses a BCECounter object to search through a deserialized game and retrieve
  the expected objectives under the current equilibrium.

  For the user's convenience, BCESolution contains static methods for
  serialization (BCESolution::save) and deserialization
  (BCESolution::load). See allpayauction.cpp for an example of how these
  are used. Serialized BCESolution objects can be loaded by BCEViewer.

  \section srcfurthertopics Further topics
  
  A brief comment is in order on the style in which the package is
  written. Every attempt was made to compartmentalize functionality
  and protect data from extraneous tampering. For that reason, almost
  all data members are private or protected and can only be accessed
  through public mutator methods.
  
  This library provides the core functionality underling the BCEViewer
  program which is described in \ref viewerpage. Please see that
  section of the documentation for a detailed description of the
  BCEViewer object model. 

 */

/*! \page viewerpage The BCEViewer graphical interface
  @brief An detailed description of the BCEViewer graphical interface.
  \section vieweroverviewsec Introduction
  
  The BCEViewer module is a graphical interface for specifying,
  solving, and exploring the solutions of games with incomplete information. The
  interface is written in the Qt framework version 5.5 and it makes
  use of the QCustomPlot library (www.qcustomplot.com). This section
  of the documentation is primarily devoted to a description of the
  object model underlying the program. For a brief description of how
  to use the graphical interface, please see \ref viewersec.
  
  The graphical interface is initialized by the BCEWindow
  class. This class constructs the rest of the interface and handles
  the high level functions that have generalized effects on the
  program: loading and saving games and solutions, solving games, and
  keyboard commands. The layout has three tabs: these are the "solution
  tab", the "game tab", and the "log tab". The solution tab is for
  exploring the solution of games, and the game tab is for
  specifying and viewing games. The log tab's function
  is primarily for displaying the progress of the algorithm during
  computation. Each of the game and solution tabs has a separate class
  associated with handling the functionality of that tab. 

  \section viewergametabsec The game tab

  The game tab is managed by an object of the BCEGameHandler class. The
  game handler contains a copy of a game, and handles the interface
  between various tables and controls for editing payoffs, the prior, the conditional
  distribution of types, and weights on objectives for optimization. The game tab displays the payoffs and conditional distribution of types for one state at a time. Different states are selected using controls at the top of the tab. 

  The editing of payoffs and probabilities is implemented using Qt's
  model-view framework. The tables themselves are of the type
  BCETableView derived from QTableView. Each table has a model
  associated with it. All models are derived from BCETableModel, which
  is derived from QAbstractTableModel. BCETableModel adds private
  members: a pointer to an associated BCEGame object and an int "state"
  member, which is the state that is currently being edited. For
  payoff tables, the model is BCEPayoffTableModel, which adds methods
  for generating header data to indicate action profiles and also
  defines setData/getData methods for interfacing with the BCEGame
  object. The table displaying the conditional distribution of types, a 
  BCEConditionalTableModel, replicates the functionality of the payoff
  table model. It handles modifying data related to the distribution of types in the
  BCEGame object. Correspondingly, the table displaying the prior over the states,
  a BCEPriorTableModel, handles modifying the prior data in the BCEGame
  object. The final table, BCEObjWeightsTableModel, manages its data internally,
  since the BCEGame object contains no data pertaining to which objectives
  will be maximized or minimized when the solve routine is run. Instead, when the solve
  routine is run, BCEGameHandler retrieves the objective weights from the
  BCEObjWeightsTableModel object.

  Since some table models are state dependent, when the current state is changed by the user,
  BCEGameHandler simply updates the state parameters of all of the
  table models and sends out signals to update the displayed
  data. Data displayed in the payoff table model and the conditional table
  model will reflect the new state. The prior table model and objective weights
  table model exist independently of the state and will not change.

  The game tab also has controls for changing the numbers of actions,
  states, and types. When these options are selected, BCEGameHandler simply
  invokves the corresponding method in the BCEGame class and signals that the models
  need to update their layouts.
  
  Finally, the game tab has a "Solve" push button which triggers the
  solve routine, and a "Cancel" push button for interrupting the
  computation. More on this in the next subsection.

  \section viewersolvesec Solving a game

  When the user presses the "Solve" button on the game tab, the signal
  is handled by the BCEWindow class which begins a computation
  using the algorithm. This computation is handled via an intermediary
  class called BCESolverWorker. To start the algorithm, the main window
  constructs a BCESolverWorker and moves it to a new thread so as not
  to freeze the program while the computation progresses. The worker
  constructs a BCESolver object for the given game. The main window
  and the worker communicate back and forth to manage the progress of
  the algorithm and output via a BCEGurobiCallback object. The callback
  object checks periodically to determine if the user has triggered the cancel
  flag, either by hitting the cancel button in the game tab or by clicking "Cancel
  Solve" in the tools menu of the menu bar at the top of the graphical interface. 
  At each of these periodic checks, the callback object uses std::cout to emit
  information about the progress of the alorithm solving the linear program.
  The main window and the worker communicate back and forth in
  this manner until the computation terminates, at which point the
  BCESolution object generated by the computation is copied to
  BCEPlotHandler and the worker is destroyed.

  \section viewersolutionsec Interacting with the solution

  When a solution is loaded through BCEWindow or when one is
  produced by solving a game, it is passed to BCEPlotHandler, which
  is the class that controls the solution tab. This tab contains
  various plots for visualizing the computations performed by the
  algorithm and the final solution of the game. BCEPlotHandler also
  passes the solution to BCEDataState, which contains methods for manipulating
  the BCESolution into vectors and matrices easily amenable to plotting.

  The solution tab presents a series of BCEValueSetPlot objects, which
  are derived from QCustomPlot. These serve to add tooltip functionality
  such as displaying coordinates when hovering the mouse over the plot. A right-click
  on the plots opens a menu with options to save a single plot as a .png or .pdf. 
  A click on points in the plot in the top left of the GUI will select new equilibria, if more
  than one equilibrium is contained within the solution object. 

  The primary function of the BCEPlotHandler is to handle the
  plotting of the data from its BCEDataState member. Which part of
  the solution is plotted depends on a number of parameters that are
  controlled by the user through various widgets. These widgets
  control the plots indirectly through the BCEDataState object. 
  This object aggregates all of the settings in the widgets
  into one set of parameters and manipulates relevant data for plotting. 
  In particular, when one of the controls is changed, the
  corresponding signal is connected to a slot in BCEDataState that
  updates the parameter value, manipulates relevant data for plotting,
  and then signals to BCEPlotHandler to replot.
  
  \section viewerotherfeatures Other features of the viewer

  There is one other feature of the BCEViewer which we will mention. 
  Three examples are built in to the tools menu in the menu bar. The 
  hybrid auction provides a parameter to control the "weight on bidder
  1's bid." A weight of 1 means bidder 1 pays 100% of his bid when he wins.
  A weight of 2 likewise means bidder 1 pays only the bid of the other bidder
  if he wins. The intermediary region thus lies between a first- and second-price
  auction. Other parameters in the generation menu for this game include a reserve
  price, entry fee, and highBid. Setting the highBid parameter below 1, the standard,
  allows more detailed (higher resolution) of the relevant bid region without 
  increasing the number of iterations the solver needs to run through. The 
  second example is a common-value auction where the prior is governed
  by a CDF of the form \f$ v^{\alpha} \f$, where \f$v\f$ is the common value in \f$[0,1]\f$. 
  The final example is a first price, private values auction.
  
 */
