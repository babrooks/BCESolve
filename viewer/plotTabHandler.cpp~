#include "plotTabHandler.h"
#include "qcustomplot.h"
#include <QtWidgets>
#include <QMenuBar>
#include <QMainWindow>
#include "bceslider.h"
#include "bcedata.hpp"

BCEWindow::BCEWindow() 
{
  path=QString("../examples/");

  // Menu Bar
  QMenu * fileMenu = menuBar()->addMenu(tr("&File"));
  QMenu * viewMenu = menuBar()->addMenu(tr("&View"));
  QAction * loadSolutionAction = new QAction(tr("&Load solution"),this);
  QAction * linearScale = new QAction(tr("&Linear Color Scale (Default)"),this);
  QAction * logScale = new QAction(tr("&Log Color Scale"),this);
  QAction * colorfulDistn = new QAction(tr("&Colorful Theme"),this);
  QAction * lightDistn = new QAction(tr("&Blue Theme (Default)"),this);
  fileMenu->addAction(loadSolutionAction);
  viewMenu->addAction(linearScale);
  viewMenu->addAction(logScale);
  viewMenu->addAction(colorfulDistn);
  viewMenu->addAction(lightDistn);
  loadSolutionAction->setShortcut(tr("Ctrl+L"));

  // Menu Connections
  connect(loadSolutionAction,SIGNAL(triggered()),this,SLOT(loadSolution()));
  connect(linearScale,SIGNAL(triggered()),this,SLOT(setLinearScale()));
  connect(logScale,SIGNAL(triggered()),this,SLOT(setLogScale()));
  connect(colorfulDistn,SIGNAL(triggered()),this,SLOT(setColorfulTheme()));
  connect(lightDistn,SIGNAL(triggered()),this,SLOT(setBlueTheme()));

  ////////////////////////////////////////////////////
  // Slider, LineEdit, and CheckBox Controls Creation

  for (int player = 0; player < 2; player++) {
    sliderGroup.push_back(new BCESlider(GUIDataState::Action,player));
    sliderGroup.push_back(new BCESlider(GUIDataState::Type,player));
    sliderGroup.push_back(new BCESlider(GUIDataState::State,player));
    lineEditGroup.push_back(new BCELineEdit(GUIDataState::Action,player));
    lineEditGroup.push_back(new BCELineEdit(GUIDataState::Type,player));
    lineEditGroup.push_back(new BCELineEdit(GUIDataState::State,player));
    checkBoxGroup.push_back(new BCECheckBox(GUIDataState::Action,player));
    checkBoxGroup.push_back(new BCECheckBox(GUIDataState::Type,player));
    checkBoxGroup.push_back(new BCECheckBox(GUIDataState::State,player));
  }

  for (int widgetIndex = 0; widgetIndex < 6; widgetIndex++) {
    lineEditGroup[widgetIndex]->setReadOnly(true);
    sliderGroup[widgetIndex]->setMaximumHeight(20);
    sliderGroup[widgetIndex]->setOrientation(Qt::Horizontal);
    lineEditGroup[widgetIndex]->setMaximumSize(30,20);
    connect(sliderGroup[widgetIndex],
	    SIGNAL(valueChanged(int,GUIDataState::BCESliderType,int)),
	    this,SLOT(changeSliderValue(int,GUIDataState::BCESliderType,int)));
    connect(sliderGroup[widgetIndex],
	    SIGNAL(valueChanged(int,GUIDataState::BCESliderType,int)),
	    lineEditGroup[widgetIndex],
	    SLOT(changeDisplayValue(int,GUIDataState::BCESliderType,int)));
    connect(checkBoxGroup[widgetIndex],
	    SIGNAL(boolChanged(bool,GUIDataState::BCESliderType,int)),
	    this,SLOT(changeMarginalBool(bool,GUIDataState::BCESliderType,int)));
  }

  // Slider Labels

  QVector<QLabel*> sliderLabels;

  sliderLabels.push_back(new QLabel(QApplication::translate("viewer","Player 0's Action")));
  sliderLabels.push_back(new QLabel(QApplication::translate("viewer","Player 0's Type")));
  sliderLabels.push_back(new QLabel(QApplication::translate("viewer","Player 0's Value")));
  sliderLabels.push_back(new QLabel(QApplication::translate("viewer","Player 1's Action")));
  sliderLabels.push_back(new QLabel(QApplication::translate("viewer","Player 1's Type")));
  sliderLabels.push_back(new QLabel(QApplication::translate("viewer","Player 1's Value")));

  for (int i = 0; i < 2; i++)
    checkBoxGroup[3*i]->setChecked(true);

  // Slider, LineEdit, and CheckBox Layout Initialization

  QVector<QHBoxLayout*> gridSubLayouts;
  QVector<QVBoxLayout*> subLayoutWithLabels;
  QGridLayout *controlsGrid = new QGridLayout(this);

  // Slider, LineEdit, and CheckBox Layout Creation
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
      gridSubLayouts.push_back(new QHBoxLayout());
      subLayoutWithLabels.push_back(new QVBoxLayout());
      sliderLabels[3*i+j]->setMaximumHeight(20);
      gridSubLayouts[3*i+j]->addWidget(sliderGroup[3*i+j]);
      gridSubLayouts[3*i+j]->addWidget(lineEditGroup[3*i+j]);
      gridSubLayouts[3*i+j]->addWidget(checkBoxGroup[3*i+j]);
      subLayoutWithLabels[3*i+j]->addWidget(sliderLabels[3*i+j]);
      subLayoutWithLabels[3*i+j]->addLayout(gridSubLayouts[3*i+j]);
      controlsGrid->addLayout(subLayoutWithLabels[3*i+j],j,i); // Layout Matrix
    } // Rows
  } // Columns

  // End Slider, LineEdit, CheckBox Creation
  //////////////////////////////////////////

  // Payoff Plot Initialization
  payoffPlot = new BCEValueSetPlot();
  payoffPlot->xAxis->setLabel("Player 0");
  payoffPlot->yAxis->setLabel("Player 1");
  payoffPlot->setMinimumSize(1920/4,1080/3.5);
  connect(payoffPlot,SIGNAL(newEqmCoordinates(double,double)),
	  this,SLOT(setNewEqm(double,double)));

  // Bar Plot Initiation 
  player0DevObj = new QCustomPlot();
  player0DevObj->xAxis->setLabel("Actions");
  player0DevObj->yAxis->setLabel("Expected Payoff");
  player0DevObj->setMinimumHeight(1080/3.5);
  player1DevObj = new QCustomPlot();
  player1DevObj->xAxis->setLabel("Actions");
  player1DevObj->yAxis->setLabel("Expected Payoff");
  player0DevObj->setMinimumHeight(1080/3.5);

  // Payoff Plot and Sliders Horizontal Layout
  QHBoxLayout *topLeftPanel = new QHBoxLayout();
  topLeftPanel->addWidget(payoffPlot);
  topLeftPanel->addLayout(controlsGrid);

  // Left Viewer Panel, Bar Plots and Slider Box
  QVBoxLayout *leftSectorDivide = new QVBoxLayout();
  leftSectorDivide->addLayout(topLeftPanel);
  leftSectorDivide->addWidget(player0DevObj);
  leftSectorDivide->addWidget(player1DevObj);

  ////////////////////////////////////////////////
  // Right Viewer Panel, Conditional-Marginal Distribution
  conditionalMarginalPlot = new QCustomPlot();

  // Plot Layout and Interaction Settings
  colorMap = new QCPColorMap(conditionalMarginalPlot->xAxis,
					  conditionalMarginalPlot->yAxis);

  conditionalMarginalPlot->addPlottable(colorMap);
  conditionalMarginalPlot->setInteractions(QCP::iRangeDrag|QCP::iRangeZoom);
  conditionalMarginalPlot->axisRect()->setupFullAxesBox(true);
  conditionalMarginalPlot->setMinimumWidth(960); // 1080p resolution
  conditionalMarginalPlot->xAxis->setLabel("Player 0");
  conditionalMarginalPlot->yAxis->setLabel("Player 1");

  // Color Plottable Set-Up and Interaction Settings
  colorScale = new QCPColorScale(conditionalMarginalPlot);

  conditionalMarginalPlot->plotLayout()->addElement(0, 1, colorScale); 
  colorMap->setColorScale(colorScale); 
  colorScale->setType(QCPAxis::atRight); 
  colorScale->axis()->setLabel("Action Probability");
  colorScale->setRangeDrag(true);
  colorMap->setTightBoundary(true);

  // Color Scale Color Choice
  QCPColorGradient *mGradient = new QCPColorGradient();
  // mGradient->gpSpectrum;
  colorMap->setGradient(mGradient->inverted());
  colorMap->setInterpolate(false);

  // END CONDITIONAL-MARGINAL
  /////////////////////////////////////////////// 

  // Layout of Left and Right Viewer Panels
  QHBoxLayout *mainTab = new QHBoxLayout();
  mainTab->addLayout(leftSectorDivide);
  mainTab->addWidget(conditionalMarginalPlot);

  // Graph Tab Setup and Main Panel Initialization
  QWidget * mainPanel = new QWidget();
  QHBoxLayout * mainLayout = new QHBoxLayout();
  QWidget * graphTab = new QWidget();

  graphTab->setLayout(mainTab);

  // Main Widget
  QTabWidget *tabWidget = new QTabWidget();
  tabWidget->addTab(graphTab,"Graphs");
  mainLayout->addWidget(tabWidget);

  mainPanel->setLayout(mainLayout);

  // Set Default Tab 
  setCentralWidget(mainPanel);

  // Maximize Window by Default
  setWindowState(Qt::WindowMaximized);

  // Window Title
  setWindowTitle(QApplication::translate("viewer","BCESolve Work in Progress"));


} // constructor

/////////////////////////////////////////////
// Load Solution Slot

void BCEWindow::loadSolution() {

  QString newPath = QFileDialog::getOpenFileName(this,tr("Select a solution file"),
						 path,
						 tr("BCESolve solution files (*.bce)"));

  if (newPath.isEmpty())
    return;

  try
    {
      QByteArray ba = newPath.toLocal8Bit();
      const char * newPath_c = ba.data();

      gui.setData(newPath_c);
      
      // Set Up Sliders for Data

      for (int i = 0; i < 6; i++) {
	sliderGroup[i]->setRange(0,gui.shareDataProperties(i)-1);
	sliderGroup[i]->setSingleStep(1);
	lineEditGroup[i]->setText("0");
      }

      // Default Load Plot
      plotAllGraphics();

    }
  catch (std::exception & e)
    {
      qDebug() << "Load solution didnt work :(" << endl;
    }
} // slot for loading a solution

/////////////////////////////////////////////
// Plot Conditional-Marginal Distribution

void BCEWindow::plotEqm(vector<vector<double>> bceEqm) {

  colorMap->clearData();
  int nx = bceEqm[0].size();
  int ny = bceEqm[1].size();
  colorMap->data()->setSize(nx, ny); 
  colorMap->data()->setRange(QCPRange(0,nx), QCPRange(0,ny)); 
  double x, y;
  double maxEntry = 0;
  for (int xIndex=0; xIndex<nx; ++xIndex)
    {
      for (int yIndex=0; yIndex<ny; ++yIndex)
	{
	  double dataPoint = bceEqm[xIndex][yIndex];
	  colorMap->data()->setCell(xIndex, yIndex, dataPoint);
	  if (dataPoint > maxEntry)
	    maxEntry = dataPoint;
	}
    }

  colorScale->setDataRange(QCPRange(0,maxEntry));

  conditionalMarginalPlot->rescaleAxes();
  conditionalMarginalPlot->xAxis->scaleRange(1.1,conditionalMarginalPlot->xAxis->range().center());
  conditionalMarginalPlot->yAxis->scaleRange(1.1,conditionalMarginalPlot->yAxis->range().center());
  conditionalMarginalPlot->replot();

} // Plot Conditional-Marginal Distribution

////////////////////////////////////
// Plot Objectives

void BCEWindow::plotBCEValueSet() {

  payoffPlot->clearGraphs();
  payoffPlot->clearPlottables();
  payoffPlot->addGraph();

  vector<vector<double>> objectives;
  objectives = gui.getObjectiveMatrix();

  QVector<double> objective0Payoffs;
  QVector<double> objective1Payoffs;

  for (int i = 0; i < objectives.size(); i++) {
    objective0Payoffs.push_back(objectives[i][gui.objective0]);
    objective1Payoffs.push_back(objectives[i][gui.objective1]);
  }

  payoffPlot->graph()->setLineStyle(QCPGraph::lsNone);
  payoffPlot->graph()->setScatterStyle(QCPScatterStyle::ssDisc);
  payoffPlot->graph()->setData(objective0Payoffs,objective1Payoffs);
  payoffPlot->graph()->rescaleAxes();
  payoffPlot->xAxis->scaleRange(1.1, payoffPlot->xAxis->range().center());
  payoffPlot->yAxis->scaleRange(1.1, payoffPlot->yAxis->range().center());
  payoffPlot->replot();

}

////////////////////////////////////
// Plot Deviation Objectives

void BCEWindow::plotDeviationObjectives(int player, vector<vector<double>> devObjs) {
  switch (player) {

  case 0: // For Player 0's Plot
    {
      player0DevObj->clearGraphs();
      player0DevObj->clearPlottables();
      QCPBars *barGraph0 = new QCPBars(player0DevObj->xAxis,
				       player0DevObj->yAxis);
      player0DevObj->addPlottable(barGraph0);
      barGraph0->setName("Expected Payoffs from Deviation");

      QVector<double> yData0;

      yData0 = QVector<double>::fromStdVector(devObjs[0]);

      int sizeYData0 = yData0.size();
      QVector<double> xData0(sizeYData0,0);

      for(int i=0; i<sizeYData0; i++) {
	xData0[i]=(double)i;
      }

      barGraph0->setData(xData0,yData0);
      player0DevObj->rescaleAxes();
      player0DevObj->replot();
    }
    break;
  case 1: // For Player 1's Plot
    {
      player1DevObj->clearGraphs();
      player1DevObj->clearPlottables();
      QCPBars *barGraph1 = new QCPBars(player1DevObj->xAxis,
				       player1DevObj->yAxis);
      player1DevObj->addPlottable(barGraph1);
      barGraph1->setName("Expected Payoffs from Deviation");

      QVector<double> yData1;

      yData1 = QVector<double>::fromStdVector(devObjs[1]);

      int sizeYData1 = yData1.size();
      QVector<double> xData1(sizeYData1,0);

      for(int i=0; i<sizeYData1; i++) {
	xData1[i]=(double)i;
      }

      barGraph1->setData(xData1,yData1);
      player1DevObj->rescaleAxes();
      player1DevObj->replot();
    }
    break;
  }

} // Plot Deviation Objectives

//////////////////////////////////
// Plot Graphics (Loading or Data Changed)

void BCEWindow::plotAllGraphics() {
    vector<vector<double>> conditionalMarginalDistn;
    conditionalMarginalDistn = gui.getEqmMatrix();
    vector<vector<double>> deviationObjectives0;
    vector<vector<double>> deviationObjectives1;
    deviationObjectives0 = gui.getObjectiveVals(0);
    deviationObjectives1 = gui.getObjectiveVals(1);
    plotEqm(conditionalMarginalDistn);
    plotDeviationObjectives(0,deviationObjectives0);
    plotDeviationObjectives(1,deviationObjectives1);
    plotBCEValueSet();
}

void BCEWindow::plotSelectGraphics(GUIDataState::BCESliderType type,int player) {

  if (type==GUIDataState::State) {
    vector<vector<double>> conditionalMarginalDistn;
    conditionalMarginalDistn = gui.getEqmMatrix();
    plotEqm(conditionalMarginalDistn);
  }

  else if (player==0) {
    vector<vector<double>> deviationObjectives0;
    deviationObjectives0 = gui.getObjectiveVals(0);
    plotDeviationObjectives(0,deviationObjectives0);
  }

  else if (player==1) {
    vector<vector<double>> deviationObjectives1;
    deviationObjectives1 = gui.getObjectiveVals(1);
    plotDeviationObjectives(1,deviationObjectives1);
  }

} // Plot Graphics

//////////////////////////////////
// Slider Slot

void BCEWindow::changeSliderValue(int newVal,GUIDataState::BCESliderType type,int player) {
  gui.setSliderData(newVal,type,player);
  plotSelectGraphics(type,player);
} // Slot to alter Actions and Types

/////////////////////////////////
// Checkbox Slot

void BCEWindow::changeMarginalBool(bool newBool,GUIDataState::BCESliderType type,int player) {
  gui.setMarginalConditions(newBool,type,player);
  plotSelectGraphics(type,player);
} // Slot to alter marginal distribution shown in Conditional Marginal  Plot

/////////////////////////////////
// BCE Value Set Slot

void BCEWindow::setNewEqm(double x,double y) {
  gui.modifyEqmFocus(x,y);
  plotAllGraphics();
}

/////////////////////////////////
// View Slots

void BCEWindow::setLinearScale() {
  colorScale->setDataScaleType(QCPAxis::stLinear);
  plotSelectGraphics(GUIDataState::State,0);
} // Slot to set a linear color scale for the distribution's heat map

void BCEWindow::setLogScale() {
  colorScale->setDataScaleType(QCPAxis::stLogarithmic);
  plotSelectGraphics(GUIDataState::State,0);
} // Slot to set a linear color scale for the distribution's heat map

void BCEWindow::setColorfulTheme() {
  QCPColorGradient *newGradient = new QCPColorGradient();
  colorMap->setGradient(newGradient->gpSpectrum);
  plotSelectGraphics(GUIDataState::State,0);
} // Slot to change color theme of heat map for conditional marginal distribution

void BCEWindow::setBlueTheme() {
  QCPColorGradient *newGradient = new QCPColorGradient();
  colorMap->setGradient(newGradient->inverted());
  plotSelectGraphics(GUIDataState::State,0);
} // Slot to change color theme of heat map for conditional marginal distribution


